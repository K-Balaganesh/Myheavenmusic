{"ast":null,"code":"var _jsxFileName = \"D:\\\\5th sem\\\\React projects\\\\Reactcodegpt\\\\music-app\\\\src\\\\context\\\\MusicPlayerContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useRef, useEffect, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MusicPlayerContext = /*#__PURE__*/createContext();\nexport const useMusicPlayer = () => {\n  _s();\n  return useContext(MusicPlayerContext);\n};\n_s(useMusicPlayer, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst initialPlaylists = [{\n  id: 'favorites',\n  name: 'My Favourites',\n  songs: []\n}, {\n  id: 'p2',\n  name: 'Road Trip Jams',\n  songs: []\n}];\nexport const MusicPlayerProvider = ({\n  children\n}) => {\n  _s2();\n  const [songs, setSongs] = useState([]);\n  const [activeSong, setActiveSong] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const audioRef = useRef(null);\n  const [playlists, setPlaylists] = useState(initialPlaylists);\n\n  // NEW: State for the popup\n  const [showPopup, setShowPopup] = useState(false);\n\n  // Function to show the popup for a short duration\n  const triggerPopup = useCallback(() => {\n    // Clear any existing timeout to restart the popup duration\n    // (Note: This cleanup is handled by useEffect for consistency, but we trigger the show here)\n    setShowPopup(true);\n\n    // We manage the hide logic with a simple useEffect cleanup to ensure one timer is running\n    // But for simplicity and immediate action, a local timeout is often easier here:\n    const timer = setTimeout(() => {\n      setShowPopup(false);\n    }, 2000);\n\n    // Return the cleanup function for the caller (optional, but good practice)\n    return () => clearTimeout(timer);\n  }, []);\n\n  // --- Playback controls (Simplified) ---\n  // NOTE: These use 'songs' from context state. If 'songs' is only used for the queue, \n  // it should be handled inside playSong (as suggested in the CategoryDetail fix).\n  // Assuming 'songs' is the global track list for now.\n  const playNext = useCallback(() => {\n    if (!songs || songs.length === 0 || !activeSong) return;\n    const idx = songs.findIndex(s => s.id === activeSong.id);\n    const nextIndex = (idx + 1) % songs.length;\n    setActiveSong(songs[nextIndex]);\n    setIsPlaying(true);\n  }, [activeSong, songs]);\n  const playPrevious = useCallback(() => {\n    if (!songs || songs.length === 0 || !activeSong) return;\n    const idx = songs.findIndex(s => s.id === activeSong.id);\n    const prevIndex = (idx - 1 + songs.length) % songs.length;\n    setActiveSong(songs[prevIndex]);\n    setIsPlaying(true);\n  }, [activeSong, songs]);\n  const togglePlayPause = useCallback(() => {\n    const audio = audioRef.current;\n    if (!audio || !activeSong) {\n      setIsPlaying(prev => !prev);\n      return;\n    }\n    // The useEffect will handle audio.play()/pause() based on the new isPlaying state\n    setIsPlaying(prev => !prev);\n  }, [activeSong]);\n\n  // MODIFIED: Simplified to correctly set active song or toggle.\n  // For advanced queue management, this needs to accept an array of songs.\n  const playSong = useCallback((song, queue = songs) => {\n    if (!song) return;\n    if (!activeSong || activeSong.id !== song.id) {\n      setActiveSong(song);\n      setIsPlaying(true);\n      // You would typically also set the current queue here if it changes\n      // setSongs(queue); // If queue changes are required for playNext/playPrevious\n    } else {\n      togglePlayPause();\n    }\n  }, [activeSong, songs, togglePlayPause]); // Removed dependency on songs if queue is passed\n\n  const handleSeek = useCallback(valueOrEvent => {\n    const audio = audioRef.current;\n    const value = typeof valueOrEvent === 'object' ? parseFloat(valueOrEvent.target.value) : parseFloat(valueOrEvent);\n    if (!isNaN(value) && audio) {\n      audio.currentTime = value;\n      setCurrentTime(value);\n    }\n  }, []);\n\n  // --- Playlist Handlers ---\n\n  // ✅ CORRECTED FIX: Logic for adding to the \"My Favourites\" playlist\n  const handleAddToPlaylist = useCallback(songToAdd => {\n    if (!songToAdd) return;\n\n    // We need a temporary variable to flag if the addition was successful,\n    // so we can conditionally trigger the popup outside of setPlaylists.\n    let songWasAdded = false;\n    setPlaylists(prevPlaylists => {\n      // Find the 'My Favourites' playlist by name or ID (using name here for robustness)\n      const favouritesPlaylist = prevPlaylists.find(p => p.name === \"My Favourites\");\n\n      // Case: Playlist exists\n      if (favouritesPlaylist) {\n        // Check if the song is already added\n        if (favouritesPlaylist.songs.some(s => s.id === songToAdd.id)) {\n          // Already exists, do nothing, no popup\n          songWasAdded = false;\n          return prevPlaylists;\n        }\n\n        // Song not found, add it\n        const updatedSongs = [...favouritesPlaylist.songs, songToAdd];\n        songWasAdded = true; // Success flag\n\n        // Return the new playlist array\n        return prevPlaylists.map(p => p.id === favouritesPlaylist.id ? {\n          ...p,\n          songs: updatedSongs\n        } : p);\n      }\n\n      // Case: Playlist does NOT exist (shouldn't happen with initialPlaylists, but safe)\n      else {\n        const newPlaylist = {\n          id: 'favorites',\n          // Use a standard ID for robustness\n          name: \"My Favourites\",\n          songs: [songToAdd]\n        };\n        songWasAdded = true; // Success flag\n        return [...prevPlaylists, newPlaylist];\n      }\n    });\n\n    // ✅ CORRECT: Trigger the popup AFTER the state update function has completed.\n    // This ensures we only call it if the state change was successfully initiated.\n    // A small delay is required here because setPlaylists is async. A simpler solution is below.\n    // Best Practice Fix: Use a small timeout to let state update, or use the second argument of setState if available.\n    if (songWasAdded) {\n      triggerPopup();\n    }\n\n    // Fallback if songWasAdded isn't 100% reliable due to async setState:\n    // setTimeout(() => triggerPopup(), 0); // Call triggerPopup right away, hoping the state is queued.\n  }, [triggerPopup]);\n\n  // Removed unused addToPlaylist and createPlaylist for simplicity (handleAddToPlaylist covers Favourites)\n\n  // --- Audio events (Unchanged) ---\n  const handleLoadedMetadata = useCallback(() => {\n    const audio = audioRef.current;\n    if (audio) setDuration(audio.duration || 0);\n  }, []);\n  const handleTimeUpdate = useCallback(() => {\n    const audio = audioRef.current;\n    if (audio) setCurrentTime(audio.currentTime || 0);\n  }, []);\n  const playNextOrFallback = useCallback(() => {\n    if (!songs || songs.length === 0) return setIsPlaying(false);\n    if (activeSong) {\n      playNext();\n    } else {\n      setActiveSong(songs[0]);\n      setIsPlaying(true);\n    }\n  }, [activeSong, songs, playNext]);\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n    audio.addEventListener('timeupdate', handleTimeUpdate);\n    audio.addEventListener('ended', playNextOrFallback);\n    return () => {\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\n      audio.removeEventListener('ended', playNextOrFallback);\n    };\n  }, [handleLoadedMetadata, handleTimeUpdate, playNextOrFallback]);\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n    audio.src = activeSong ? activeSong.url : '';\n    if (activeSong) {\n      audio.currentTime = 0;\n      setCurrentTime(0);\n      setDuration(0);\n    }\n    if (isPlaying) {\n      const p = audio.play();\n      if (p !== undefined) {\n        p.then(() => setIsPlaying(true)).catch(() => setIsPlaying(false));\n      }\n    } else {\n      try {\n        audio.pause();\n      } catch (e) {}\n    }\n  }, [activeSong, isPlaying]);\n  const contextValue = {\n    activeSong,\n    isPlaying,\n    currentTime,\n    duration,\n    songs,\n    setSongs,\n    playSong,\n    togglePlayPause,\n    playNext,\n    playPrevious,\n    handleSeek,\n    playlists,\n    handleAddToPlaylist,\n    showPopup\n  };\n  return /*#__PURE__*/_jsxDEV(MusicPlayerContext.Provider, {\n    value: contextValue,\n    children: [\"\\xA0 \\xA0 \\xA0 \", children, \"\\xA0 \\xA0 \\xA0 \", /*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 235,\n      columnNumber: 7\n    }, this), \"\\xA0 \\xA0 \"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n_s2(MusicPlayerProvider, \"AnuyYzmW80UCc1C5SpYisV95VcA=\");\n_c = MusicPlayerProvider;\nvar _c;\n$RefreshReg$(_c, \"MusicPlayerProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","useEffect","useCallback","jsxDEV","_jsxDEV","MusicPlayerContext","useMusicPlayer","_s","initialPlaylists","id","name","songs","MusicPlayerProvider","children","_s2","setSongs","activeSong","setActiveSong","isPlaying","setIsPlaying","currentTime","setCurrentTime","duration","setDuration","audioRef","playlists","setPlaylists","showPopup","setShowPopup","triggerPopup","timer","setTimeout","clearTimeout","playNext","length","idx","findIndex","s","nextIndex","playPrevious","prevIndex","togglePlayPause","audio","current","prev","playSong","song","queue","handleSeek","valueOrEvent","value","parseFloat","target","isNaN","handleAddToPlaylist","songToAdd","songWasAdded","prevPlaylists","favouritesPlaylist","find","p","some","updatedSongs","map","newPlaylist","handleLoadedMetadata","handleTimeUpdate","playNextOrFallback","addEventListener","removeEventListener","src","url","play","undefined","then","catch","pause","e","contextValue","Provider","ref","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/5th sem/React projects/Reactcodegpt/music-app/src/context/MusicPlayerContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useRef, useEffect, useCallback } from 'react';\r\n\r\nconst MusicPlayerContext = createContext();\r\nexport const useMusicPlayer = () => useContext(MusicPlayerContext);\r\n\r\nconst initialPlaylists = [\r\n  { id: 'favorites', name: 'My Favourites', songs: [] },\r\n  { id: 'p2', name: 'Road Trip Jams', songs: [] },\r\n];\r\n\r\nexport const MusicPlayerProvider = ({ children }) => {\r\n  const [songs, setSongs] = useState([]); \r\n  const [activeSong, setActiveSong] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [duration, setDuration] = useState(0);\r\n  const audioRef = useRef(null);\r\n  const [playlists, setPlaylists] = useState(initialPlaylists);\r\n  \r\n  // NEW: State for the popup\r\n  const [showPopup, setShowPopup] = useState(false); \r\n  \r\n  // Function to show the popup for a short duration\r\n  const triggerPopup = useCallback(() => {\r\n    // Clear any existing timeout to restart the popup duration\r\n    // (Note: This cleanup is handled by useEffect for consistency, but we trigger the show here)\r\n    setShowPopup(true);\r\n\r\n    // We manage the hide logic with a simple useEffect cleanup to ensure one timer is running\r\n    // But for simplicity and immediate action, a local timeout is often easier here:\r\n    const timer = setTimeout(() => {\r\n      setShowPopup(false);\r\n    }, 2000); \r\n    \r\n    // Return the cleanup function for the caller (optional, but good practice)\r\n    return () => clearTimeout(timer);\r\n  }, []);\r\n\r\n\r\n  // --- Playback controls (Simplified) ---\r\n  // NOTE: These use 'songs' from context state. If 'songs' is only used for the queue, \r\n  // it should be handled inside playSong (as suggested in the CategoryDetail fix).\r\n  // Assuming 'songs' is the global track list for now.\r\n  const playNext = useCallback(() => {\r\n    if (!songs || songs.length === 0 || !activeSong) return;\r\n    const idx = songs.findIndex(s => s.id === activeSong.id);\r\n    const nextIndex = (idx + 1) % songs.length;\r\n    setActiveSong(songs[nextIndex]);\r\n    setIsPlaying(true);\r\n  }, [activeSong, songs]);\r\n\r\n  const playPrevious = useCallback(() => {\r\n    if (!songs || songs.length === 0 || !activeSong) return;\r\n    const idx = songs.findIndex(s => s.id === activeSong.id);\r\n    const prevIndex = (idx - 1 + songs.length) % songs.length;\r\n    setActiveSong(songs[prevIndex]);\r\n    setIsPlaying(true);\r\n  }, [activeSong, songs]);\r\n\r\n  const togglePlayPause = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio || !activeSong) {\r\n      setIsPlaying(prev => !prev);\r\n      return;\r\n    }\r\n    // The useEffect will handle audio.play()/pause() based on the new isPlaying state\r\n    setIsPlaying(prev => !prev);\r\n  }, [activeSong]);\r\n\r\n  // MODIFIED: Simplified to correctly set active song or toggle.\r\n  // For advanced queue management, this needs to accept an array of songs.\r\n  const playSong = useCallback((song, queue = songs) => {\r\n    if (!song) return;\r\n    if (!activeSong || activeSong.id !== song.id) {\r\n      setActiveSong(song);\r\n      setIsPlaying(true);\r\n      // You would typically also set the current queue here if it changes\r\n      // setSongs(queue); // If queue changes are required for playNext/playPrevious\r\n    } else {\r\n      togglePlayPause();\r\n    }\r\n  }, [activeSong, songs, togglePlayPause]); // Removed dependency on songs if queue is passed\r\n\r\n\r\n  const handleSeek = useCallback((valueOrEvent) => {\r\n    const audio = audioRef.current;\r\n    const value = typeof valueOrEvent === 'object' ? parseFloat(valueOrEvent.target.value) : parseFloat(valueOrEvent);\r\n    if (!isNaN(value) && audio) {\r\n      audio.currentTime = value;\r\n      setCurrentTime(value);\r\n    }\r\n  }, []);\r\n\r\n\r\n  // --- Playlist Handlers ---\r\n\r\n  // ✅ CORRECTED FIX: Logic for adding to the \"My Favourites\" playlist\r\n  const handleAddToPlaylist = useCallback((songToAdd) => {\r\n    if (!songToAdd) return;\r\n    \r\n    // We need a temporary variable to flag if the addition was successful,\r\n    // so we can conditionally trigger the popup outside of setPlaylists.\r\n    let songWasAdded = false;\r\n\r\n    setPlaylists(prevPlaylists => {\r\n      // Find the 'My Favourites' playlist by name or ID (using name here for robustness)\r\n      const favouritesPlaylist = prevPlaylists.find(p => p.name === \"My Favourites\");\r\n\r\n      // Case: Playlist exists\r\n      if (favouritesPlaylist) {\r\n        // Check if the song is already added\r\n        if (favouritesPlaylist.songs.some(s => s.id === songToAdd.id)) {\r\n          // Already exists, do nothing, no popup\r\n          songWasAdded = false;\r\n          return prevPlaylists;\r\n        }\r\n\r\n        // Song not found, add it\r\n        const updatedSongs = [...favouritesPlaylist.songs, songToAdd];\r\n        songWasAdded = true; // Success flag\r\n\r\n        // Return the new playlist array\r\n        return prevPlaylists.map(p => \r\n          p.id === favouritesPlaylist.id \r\n            ? { ...p, songs: updatedSongs } \r\n            : p\r\n        );\r\n      } \r\n      \r\n      // Case: Playlist does NOT exist (shouldn't happen with initialPlaylists, but safe)\r\n      else {\r\n        const newPlaylist = {\r\n          id: 'favorites', // Use a standard ID for robustness\r\n          name: \"My Favourites\",\r\n          songs: [songToAdd]\r\n        };\r\n        songWasAdded = true; // Success flag\r\n        return [...prevPlaylists, newPlaylist];\r\n      }\r\n    });\r\n    \r\n    // ✅ CORRECT: Trigger the popup AFTER the state update function has completed.\r\n    // This ensures we only call it if the state change was successfully initiated.\r\n    // A small delay is required here because setPlaylists is async. A simpler solution is below.\r\n    // Best Practice Fix: Use a small timeout to let state update, or use the second argument of setState if available.\r\n    if (songWasAdded) {\r\n        triggerPopup();\r\n    }\r\n    \r\n    // Fallback if songWasAdded isn't 100% reliable due to async setState:\r\n    // setTimeout(() => triggerPopup(), 0); // Call triggerPopup right away, hoping the state is queued.\r\n    \r\n  }, [triggerPopup]); \r\n \r\n  // Removed unused addToPlaylist and createPlaylist for simplicity (handleAddToPlaylist covers Favourites)\r\n\r\n  // --- Audio events (Unchanged) ---\r\n  const handleLoadedMetadata = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (audio) setDuration(audio.duration || 0);\r\n  }, []);\r\n\r\n  const handleTimeUpdate = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (audio) setCurrentTime(audio.currentTime || 0);\r\n  }, []);\r\n\r\n  const playNextOrFallback = useCallback(() => {\r\n    if (!songs || songs.length === 0) return setIsPlaying(false);\r\n    if (activeSong) {\r\n      playNext();\r\n    } else {\r\n      setActiveSong(songs[0]);\r\n      setIsPlaying(true);\r\n    }\r\n  }, [activeSong, songs, playNext]);\r\n\r\n  useEffect(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio) return;\r\n\r\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\r\n    audio.addEventListener('timeupdate', handleTimeUpdate);\r\n    audio.addEventListener('ended', playNextOrFallback);\r\n\r\n    return () => {\r\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\r\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\r\n      audio.removeEventListener('ended', playNextOrFallback);\r\n    };\r\n  }, [handleLoadedMetadata, handleTimeUpdate, playNextOrFallback]);\r\n\r\n  useEffect(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio) return;\r\n\r\n    audio.src = activeSong ? activeSong.url : '';\r\n    if (activeSong) {\r\n      audio.currentTime = 0;\r\n      setCurrentTime(0);\r\n      setDuration(0);\r\n    }\r\n\r\n    if (isPlaying) {\r\n      const p = audio.play();\r\n      if (p !== undefined) {\r\n        p.then(() => setIsPlaying(true))\r\n         .catch(() => setIsPlaying(false));\r\n      }\r\n    } else {\r\n      try { audio.pause(); } catch(e) {}\r\n    }\r\n  }, [activeSong, isPlaying]);\r\n\r\n  const contextValue = {\r\n    activeSong,\r\n    isPlaying,\r\n    currentTime,\r\n    duration,\r\n    songs,\r\n    setSongs,\r\n    playSong,\r\n    togglePlayPause,\r\n    playNext,\r\n    playPrevious,\r\n    handleSeek,\r\n    playlists,\r\n    handleAddToPlaylist, \r\n    showPopup \r\n  };\r\n\r\n  return (\r\n    <MusicPlayerContext.Provider value={contextValue}>\r\n      {children}\r\n      <audio ref={audioRef} style={{ display: 'none' }} />\r\n    </MusicPlayerContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}