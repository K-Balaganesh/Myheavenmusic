{"ast":null,"code":"var _jsxFileName = \"D:\\\\5th sem\\\\React projects\\\\Reactcodegpt\\\\music-app\\\\src\\\\context\\\\MusicPlayerContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useRef, useEffect, useCallback } from 'react';\n\n// Define the context and hook\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MusicPlayerContext = /*#__PURE__*/createContext();\nexport const useMusicPlayer = () => {\n  _s();\n  return useContext(MusicPlayerContext);\n};\n\n// Initial default playlists\n_s(useMusicPlayer, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst initialPlaylists = [{\n  id: 'p1',\n  name: 'My Favourites',\n  songs: []\n}, {\n  id: 'p2',\n  name: 'Road Trip Jams',\n  songs: []\n}];\nexport const MusicPlayerProvider = ({\n  children\n}) => {\n  _s2();\n  const [songs, setSongs] = useState([]);\n  const [activeSong, setActiveSong] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const audioRef = useRef(null);\n  const [playlists, setPlaylists] = useState(initialPlaylists);\n\n  // State for the popup notification\n  const [showPopup, setShowPopup] = useState(false);\n\n  // Function to show the popup for a short duration\n  const triggerPopup = useCallback(() => {\n    setShowPopup(true);\n    const timer = setTimeout(() => {\n      setShowPopup(false);\n    }, 2000); // Popup shown for 2 seconds\n    return () => clearTimeout(timer);\n  }, []);\n\n  // --- Playback Controls ---\n\n  const playNext = useCallback(() => {\n    if (!songs || songs.length === 0 || !activeSong) return;\n    const idx = songs.findIndex(s => s.id === activeSong.id);\n    // Calculate the index for the next song, wrapping around using modulo\n    const nextIndex = (idx + 1) % songs.length;\n    setActiveSong(songs[nextIndex]);\n    setIsPlaying(true);\n  }, [activeSong, songs]);\n  const playPrevious = useCallback(() => {\n    if (!songs || songs.length === 0 || !activeSong) return;\n    const idx = songs.findIndex(s => s.id === activeSong.id);\n    // Calculate the index for the previous song, handling the wrap-around\n    const prevIndex = (idx - 1 + songs.length) % songs.length;\n    setActiveSong(songs[prevIndex]);\n    setIsPlaying(true);\n  }, [activeSong, songs]);\n  const togglePlayPause = useCallback(() => {\n    const audio = audioRef.current;\n    if (!audio || !activeSong) {\n      // If no audio element or active song, just toggle the state for UI update\n      setIsPlaying(prev => !prev);\n      return;\n    }\n    if (isPlaying) {\n      audio.pause();\n      setIsPlaying(false);\n    } else {\n      const p = audio.play();\n      if (p !== undefined) {\n        p.then(() => setIsPlaying(true)).catch(() => setIsPlaying(false)); // Catch error if play fails (e.g., policy)\n      } else {\n        setIsPlaying(true);\n      }\n    }\n  }, [isPlaying, activeSong]);\n  const playSong = useCallback(song => {\n    if (!song) return;\n    if (!activeSong || activeSong.id !== song.id) {\n      setActiveSong(song);\n      setIsPlaying(true);\n    } else {\n      // If the same song is clicked, toggle play/pause\n      togglePlayPause();\n    }\n  }, [activeSong, togglePlayPause]);\n  const handleSeek = useCallback(valueOrEvent => {\n    const audio = audioRef.current;\n    const value = typeof valueOrEvent === 'object' ? parseFloat(valueOrEvent.target.value) : parseFloat(valueOrEvent);\n    if (!isNaN(value) && audio) {\n      audio.currentTime = value;\n      setCurrentTime(value);\n    }\n  }, []);\n\n  // --- Playlist Management ---\n\n  // Helper function to add a song to an existing playlist by ID\n  const addToPlaylist = useCallback((playlistId, song) => {\n    if (!song) return;\n    setPlaylists(prev => prev.map(pl => pl.id === playlistId\n    // Check if the song already exists before adding\n    ? pl.songs.some(s => s.id === song.id) ? pl : {\n      ...pl,\n      songs: [...pl.songs, song]\n    } : pl));\n  }, []);\n\n  // Helper function to create a new playlist\n  const createPlaylist = useCallback((name, initialSong = null) => {\n    const newPlaylist = {\n      id: Date.now().toString(),\n      name: name || `New Playlist`,\n      songs: initialSong ? [initialSong] : []\n    };\n    setPlaylists(prev => [...prev, newPlaylist]);\n    return newPlaylist;\n  }, []);\n\n  // FIX: Handles adding a song to \"My Favourites,\" receiving the song directly from the component.\n  const handleAddToPlaylist = useCallback(songToAdd => {\n    if (!songToAdd) return;\n    setPlaylists(prevPlaylists => {\n      let favourites = prevPlaylists.find(p => p.name === \"My Favourites\");\n\n      // If song already exists in Favourites, do nothing\n      if (favourites && favourites.songs.some(s => s.id === songToAdd.id)) {\n        return prevPlaylists;\n      }\n      let updatedPlaylists;\n\n      // Case 1: \"My Favourites\" playlist exists\n      if (favourites) {\n        updatedPlaylists = prevPlaylists.map(pl => pl.id === favourites.id ? {\n          ...pl,\n          songs: [...pl.songs, songToAdd]\n        } : pl);\n      }\n\n      // Case 2: \"My Favourites\" playlist does not exist (Create it)\n      else {\n        const newPlaylist = {\n          id: Date.now().toString(),\n          name: \"My Favourites\",\n          songs: [songToAdd]\n        };\n        updatedPlaylists = [...prevPlaylists, newPlaylist];\n      }\n\n      // Trigger success popup only if the playlist was updated\n      triggerPopup();\n      return updatedPlaylists;\n    });\n  }, [triggerPopup]); // Removed unnecessary dependencies by using functional update\n\n  // --- Audio Events & Effects ---\n\n  const handleLoadedMetadata = useCallback(() => {\n    const audio = audioRef.current;\n    if (audio) setDuration(audio.duration || 0);\n  }, []);\n  const handleTimeUpdate = useCallback(() => {\n    const audio = audioRef.current;\n    if (audio) setCurrentTime(audio.currentTime || 0);\n  }, []);\n  const playNextOrFallback = useCallback(() => {\n    if (!songs || songs.length === 0) return setIsPlaying(false);\n    if (activeSong) {\n      playNext(); // Play the next song in the queue\n    } else {\n      setActiveSong(songs[0]); // Fallback to the first song\n      setIsPlaying(true);\n    }\n  }, [activeSong, songs, playNext]);\n\n  // Effect for setting up audio event listeners\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n    audio.addEventListener('timeupdate', handleTimeUpdate);\n    audio.addEventListener('ended', playNextOrFallback);\n    return () => {\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\n      audio.removeEventListener('ended', playNextOrFallback);\n    };\n  }, [handleLoadedMetadata, handleTimeUpdate, playNextOrFallback]);\n\n  // Effect for handling song change (setting URL and play/pause state)\n  useEffect(() => {\n    const audio = audioRef.current;\n    if (!audio) return;\n    audio.src = activeSong ? activeSong.url : '';\n    if (activeSong) {\n      // Reset time/duration when a new song starts\n      audio.currentTime = 0;\n      setCurrentTime(0);\n      setDuration(0);\n    }\n    if (isPlaying) {\n      const p = audio.play();\n      if (p !== undefined) {\n        p.then(() => setIsPlaying(true)).catch(() => setIsPlaying(false));\n      }\n    } else {\n      try {\n        audio.pause();\n      } catch (e) {}\n    }\n  }, [activeSong, isPlaying]);\n  const contextValue = {\n    activeSong,\n    isPlaying,\n    currentTime,\n    duration,\n    songs,\n    setSongs,\n    playSong,\n    togglePlayPause,\n    playNext,\n    playPrevious,\n    handleSeek,\n    playlists,\n    addToPlaylist,\n    createPlaylist,\n    handleAddToPlaylist,\n    showPopup\n  };\n  return /*#__PURE__*/_jsxDEV(MusicPlayerContext.Provider, {\n    value: contextValue,\n    children: [\"\\xA0 \\xA0 \\xA0 \", children, \"\\xA0 \\xA0 \\xA0 \", /*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 250,\n      columnNumber: 7\n    }, this), \"\\xA0 \\xA0 \"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 248,\n    columnNumber: 5\n  }, this);\n};\n_s2(MusicPlayerProvider, \"rQnjMPwynJpixl0UuGBzeziVnDA=\");\n_c = MusicPlayerProvider;\nvar _c;\n$RefreshReg$(_c, \"MusicPlayerProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useRef","useEffect","useCallback","jsxDEV","_jsxDEV","MusicPlayerContext","useMusicPlayer","_s","initialPlaylists","id","name","songs","MusicPlayerProvider","children","_s2","setSongs","activeSong","setActiveSong","isPlaying","setIsPlaying","currentTime","setCurrentTime","duration","setDuration","audioRef","playlists","setPlaylists","showPopup","setShowPopup","triggerPopup","timer","setTimeout","clearTimeout","playNext","length","idx","findIndex","s","nextIndex","playPrevious","prevIndex","togglePlayPause","audio","current","prev","pause","p","play","undefined","then","catch","playSong","song","handleSeek","valueOrEvent","value","parseFloat","target","isNaN","addToPlaylist","playlistId","map","pl","some","createPlaylist","initialSong","newPlaylist","Date","now","toString","handleAddToPlaylist","songToAdd","prevPlaylists","favourites","find","updatedPlaylists","handleLoadedMetadata","handleTimeUpdate","playNextOrFallback","addEventListener","removeEventListener","src","url","e","contextValue","Provider","ref","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/5th sem/React projects/Reactcodegpt/music-app/src/context/MusicPlayerContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useRef, useEffect, useCallback } from 'react';\r\n\r\n// Define the context and hook\r\nconst MusicPlayerContext = createContext();\r\nexport const useMusicPlayer = () => useContext(MusicPlayerContext);\r\n\r\n// Initial default playlists\r\nconst initialPlaylists = [\r\n  { id: 'p1', name: 'My Favourites', songs: [] },\r\n  { id: 'p2', name: 'Road Trip Jams', songs: [] },\r\n];\r\n\r\nexport const MusicPlayerProvider = ({ children }) => {\r\n  const [songs, setSongs] = useState([]); \r\n  const [activeSong, setActiveSong] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [duration, setDuration] = useState(0);\r\n  const audioRef = useRef(null);\r\n  const [playlists, setPlaylists] = useState(initialPlaylists);\r\n  \r\n  // State for the popup notification\r\n  const [showPopup, setShowPopup] = useState(false); \r\n  \r\n  // Function to show the popup for a short duration\r\n  const triggerPopup = useCallback(() => {\r\n    setShowPopup(true);\r\n    const timer = setTimeout(() => {\r\n      setShowPopup(false);\r\n    }, 2000); // Popup shown for 2 seconds\r\n    return () => clearTimeout(timer);\r\n  }, []);\r\n\r\n\r\n  // --- Playback Controls ---\r\n\r\n  const playNext = useCallback(() => {\r\n    if (!songs || songs.length === 0 || !activeSong) return;\r\n    \r\n    const idx = songs.findIndex(s => s.id === activeSong.id);\r\n    // Calculate the index for the next song, wrapping around using modulo\r\n    const nextIndex = (idx + 1) % songs.length; \r\n    \r\n    setActiveSong(songs[nextIndex]);\r\n    setIsPlaying(true);\r\n  }, [activeSong, songs]);\r\n\r\n  const playPrevious = useCallback(() => {\r\n    if (!songs || songs.length === 0 || !activeSong) return;\r\n    \r\n    const idx = songs.findIndex(s => s.id === activeSong.id);\r\n    // Calculate the index for the previous song, handling the wrap-around\r\n    const prevIndex = (idx - 1 + songs.length) % songs.length; \r\n    \r\n    setActiveSong(songs[prevIndex]);\r\n    setIsPlaying(true);\r\n  }, [activeSong, songs]);\r\n\r\n  const togglePlayPause = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio || !activeSong) {\r\n        // If no audio element or active song, just toggle the state for UI update\r\n        setIsPlaying(prev => !prev);\r\n        return;\r\n    }\r\n    if (isPlaying) {\r\n      audio.pause();\r\n      setIsPlaying(false);\r\n    } else {\r\n      const p = audio.play();\r\n      if (p !== undefined) {\r\n        p.then(() => setIsPlaying(true))\r\n         .catch(() => setIsPlaying(false)); // Catch error if play fails (e.g., policy)\r\n      } else {\r\n        setIsPlaying(true);\r\n      }\r\n    }\r\n  }, [isPlaying, activeSong]);\r\n\r\n  const playSong = useCallback((song) => {\r\n    if (!song) return;\r\n    if (!activeSong || activeSong.id !== song.id) {\r\n      setActiveSong(song);\r\n      setIsPlaying(true);\r\n    } else {\r\n      // If the same song is clicked, toggle play/pause\r\n      togglePlayPause();\r\n    }\r\n  }, [activeSong, togglePlayPause]);\r\n\r\n  const handleSeek = useCallback((valueOrEvent) => {\r\n    const audio = audioRef.current;\r\n    const value = typeof valueOrEvent === 'object' ? parseFloat(valueOrEvent.target.value) : parseFloat(valueOrEvent);\r\n    if (!isNaN(value) && audio) {\r\n      audio.currentTime = value;\r\n      setCurrentTime(value);\r\n    }\r\n  }, []);\r\n\r\n\r\n  // --- Playlist Management ---\r\n\r\n  // Helper function to add a song to an existing playlist by ID\r\n  const addToPlaylist = useCallback((playlistId, song) => {\r\n    if (!song) return;\r\n    setPlaylists(prev =>\r\n      prev.map(pl => pl.id === playlistId\r\n        // Check if the song already exists before adding\r\n        ? (pl.songs.some(s => s.id === song.id) ? pl : { ...pl, songs: [...pl.songs, song] })\r\n        : pl\r\n      )\r\n    );\r\n  }, []);\r\n\r\n  // Helper function to create a new playlist\r\n  const createPlaylist = useCallback((name, initialSong = null) => {\r\n    const newPlaylist = {\r\n      id: Date.now().toString(),\r\n      name: name || `New Playlist`,\r\n      songs: initialSong ? [initialSong] : []\r\n    };\r\n    setPlaylists(prev => [...prev, newPlaylist]);\r\n    return newPlaylist;\r\n  }, []);\r\n\r\n  // FIX: Handles adding a song to \"My Favourites,\" receiving the song directly from the component.\r\n  const handleAddToPlaylist = useCallback((songToAdd) => {\r\n    if (!songToAdd) return;\r\n    \r\n    setPlaylists(prevPlaylists => {\r\n      let favourites = prevPlaylists.find(p => p.name === \"My Favourites\");\r\n\r\n      // If song already exists in Favourites, do nothing\r\n      if (favourites && favourites.songs.some(s => s.id === songToAdd.id)) {\r\n        return prevPlaylists; \r\n      }\r\n\r\n      let updatedPlaylists;\r\n\r\n      // Case 1: \"My Favourites\" playlist exists\r\n      if (favourites) {\r\n        updatedPlaylists = prevPlaylists.map(pl => \r\n          pl.id === favourites.id \r\n            ? { ...pl, songs: [...pl.songs, songToAdd] } \r\n            : pl\r\n        );\r\n      } \r\n      \r\n      // Case 2: \"My Favourites\" playlist does not exist (Create it)\r\n      else {\r\n        const newPlaylist = {\r\n          id: Date.now().toString(),\r\n          name: \"My Favourites\",\r\n          songs: [songToAdd]\r\n        };\r\n        updatedPlaylists = [...prevPlaylists, newPlaylist];\r\n      }\r\n      \r\n      // Trigger success popup only if the playlist was updated\r\n      triggerPopup();\r\n      return updatedPlaylists;\r\n    });\r\n  }, [triggerPopup]); // Removed unnecessary dependencies by using functional update\r\n\r\n  // --- Audio Events & Effects ---\r\n\r\n  const handleLoadedMetadata = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (audio) setDuration(audio.duration || 0);\r\n  }, []);\r\n\r\n  const handleTimeUpdate = useCallback(() => {\r\n    const audio = audioRef.current;\r\n    if (audio) setCurrentTime(audio.currentTime || 0);\r\n  }, []);\r\n\r\n  const playNextOrFallback = useCallback(() => {\r\n    if (!songs || songs.length === 0) return setIsPlaying(false);\r\n    if (activeSong) {\r\n      playNext(); // Play the next song in the queue\r\n    } else {\r\n      setActiveSong(songs[0]); // Fallback to the first song\r\n      setIsPlaying(true);\r\n    }\r\n  }, [activeSong, songs, playNext]);\r\n\r\n  // Effect for setting up audio event listeners\r\n  useEffect(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio) return;\r\n\r\n    audio.addEventListener('loadedmetadata', handleLoadedMetadata);\r\n    audio.addEventListener('timeupdate', handleTimeUpdate);\r\n    audio.addEventListener('ended', playNextOrFallback);\r\n\r\n    return () => {\r\n      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\r\n      audio.removeEventListener('timeupdate', handleTimeUpdate);\r\n      audio.removeEventListener('ended', playNextOrFallback);\r\n    };\r\n  }, [handleLoadedMetadata, handleTimeUpdate, playNextOrFallback]);\r\n\r\n  // Effect for handling song change (setting URL and play/pause state)\r\n  useEffect(() => {\r\n    const audio = audioRef.current;\r\n    if (!audio) return;\r\n\r\n    audio.src = activeSong ? activeSong.url : '';\r\n    \r\n    if (activeSong) {\r\n      // Reset time/duration when a new song starts\r\n      audio.currentTime = 0;\r\n      setCurrentTime(0);\r\n      setDuration(0);\r\n    }\r\n\r\n    if (isPlaying) {\r\n      const p = audio.play();\r\n      if (p !== undefined) {\r\n        p.then(() => setIsPlaying(true))\r\n         .catch(() => setIsPlaying(false));\r\n      }\r\n    } else {\r\n      try { audio.pause(); } catch(e) {}\r\n    }\r\n  }, [activeSong, isPlaying]);\r\n\r\n  const contextValue = {\r\n    activeSong,\r\n    isPlaying,\r\n    currentTime,\r\n    duration,\r\n    songs,\r\n    setSongs,\r\n    playSong,\r\n    togglePlayPause,\r\n    playNext,\r\n    playPrevious,\r\n    handleSeek,\r\n    playlists,\r\n    addToPlaylist,\r\n    createPlaylist,\r\n    handleAddToPlaylist, \r\n    showPopup \r\n  };\r\n\r\n  return (\r\n    <MusicPlayerContext.Provider value={contextValue}>\r\n      {children}\r\n      <audio ref={audioRef} style={{ display: 'none' }} />\r\n    </MusicPlayerContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}